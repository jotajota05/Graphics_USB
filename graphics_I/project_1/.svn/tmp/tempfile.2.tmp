#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string.h>
#include <vector>

#include "brick.h"
#include "sphere.h"
#include "base.h"

using namespace std;

int camera_x = 5.0;
int camera_y = 5.0;
int camera_z = -5.0;
int camera_type = 1;
pair <char,int> keys[5];
Brick* brick_list[9][6];
Sphere* ball = new Sphere();;
Base* bar = new Base();
int first = 1;

void ejes() {
  glBegin(GL_LINES);
  glColor3f(1.0, 0.0, 0.0); // Eje X en rojo
  glVertex3f(200.0, 0.0, 0.0);
  glVertex3f(-200.0, 0.0, 0.0);
  glColor3f(0.0, 1.0, 0.0); // Eje Z en azul
  glVertex3f(0.0, 200.0, 0.0);
  glVertex3f(0.0, -200.0, 0.0);
  glColor3f(0.0, 0.0, 1.0); // Eje Y en verde
  glVertex3f(0.0, 0.0, 200.0);
  glVertex3f(0.0, 0.0, -200.0);
  glEnd();
}

void initGL(int width, int height) {		       
  glClearColor(0.0, 0.0, 0.0, 0.5);
  glClearDepth(1);
  glDepthFunc(GL_LESS);		
  glEnable(GL_DEPTH_TEST);		
  glShadeModel(GL_SMOOTH);	        
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();			
  gluPerspective(45.0, width/height, 0.1, 100.0);
  glMatrixMode(GL_MODELVIEW);
}

void drawBackground(int x_worldSize, int z_worldSize) {
  glColor3f(0.5f,0.5f,1.0f);
  glBegin(GL_QUADS);		
  glVertex3f(0.0, -0.1, z_worldSize);
  glVertex3f(x_worldSize, 0.0, z_worldSize);
  glVertex3f(x_worldSize, 0.0, 0.0);
  glVertex3f(0.0, -0.1, 0.0);
  glEnd();
}

void initKeys() {
  keys[0].first = 'i';
  keys[0].second = 0;

  keys[1].first = 'k';
  keys[1].second = 0;

  keys[2].first = 'l';
  keys[2].second = 0;

  keys[3].first = 'j';
  keys[3].second = 0;

  keys[4].first = 'c';
  keys[4].second = 0;
}

void keyPressed(unsigned char key, int x, int y) {
  int i;

  for (i = 0; i < 5; i++) {
    if (keys[i].first == key) {
      keys[i].second = 1;
      break;
    }
  }
}

int searchKey(char key) {
  int i;
  
  for (i = 0; i < 5; i++) {
    if (keys[i].first == key) {
      return keys[i].second;
    }
  }

  return 0;
}
  
void keysFunc() {  
  if (searchKey('i')) // Camera X up
    camera_x += 1;
  if (searchKey('k')) // Camera X down
    camera_x -= 1;        
  if (searchKey('l')) // Camera z up
    camera_z += 1;
  if (searchKey('j')) // Camera z down
    camera_z -= 1;
  if (searchKey('c')) { // Camera z down
    if (camera_type == 1) {
      camera_type = 2;
      camera_x = camera_x - 35.0;
      camera_y = 45.0;
      camera_z = camera_z - 16.0;
    }
    else {
      camera_type = 1;
      camera_x = camera_x + 35.0;
      camera_y = 15.0;
      camera_z = camera_z + 16.0;
    }
  }  

  initKeys();
}

void drawWalls() {
  //Pared izquierda
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(0.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared derecha
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(36.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared arriba
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 60.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared abajo
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 0.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();
}

/*void createBricks() {
  float x = 30.0;
  float z = 52.0;
  int i,j;
  int static_bricks = 10;
  int base_bonus, ball_bonus;
  base_bonus = ball_bonus = 5;

  for (j = 0; j < 6; j++) {

    for (i = 0; i < 9; i++) {

      brick_list[j][i] = new Brick();
      brick_list[j][i]->x = x;
      brick_list[j][i]->z = z;
      brick_list[j][i]->red = 1.0;

//       if (static_bricks > 0) {
// 	if ((rand() % 100) <= 50) {
// 	  if (base_bonus > 0) {
// 	    if ((rand() % 100) <= 50) {
// 	      brick_list[j][i]->bonus.first = 1;
// 	      brick_list[j][i]->blue = 1.0;
// 	      base_bonus -= 1;
// 	    }
// 	  }
// 	  else if (ball_bonus > 0) {
// 	    if ((rand() % 100) <= 50) {	    
// 	      brick_list[j][i]->bonus.first = 1;
// 	      brick_list[j][i]->green = 1.0;
// 	      ball_bonus -= 1;
// 	    }
// 	  }
// 	}
// 	else {
// 	  brick_list[j][i]->type = 1;
// 	  brick_list[j][i]->red = 0.0;
// 	  brick_list[j][i]->green = 1.0;
// 	  static_bricks -= 1;
// 	}
//       }

      x -= 3.0;
    }

    z -= 3.0;
    x = 30.0;
  }
  }*/

void createBricks() {
  float x = 30.0;
  float z = 52.0;
  int i,j;

  for (j = 0; j < 6; j++) {

    for (i = 0; i < 9; i++) {
      if (first) 
	brick_list[j][i] = new Brick();	
      
      brick_list[j][i]->x = x;
      brick_list[j][i]->z = z;
      brick_list[j][i]->red = 1.0;
      brick_list[j][i]->draw();
      x -= 3.0;
      
    }
    z -= 3.0;
    x = 30.0;

  }
  
  first = 0;
}

void drawBricks() {
  int i, j;
 
  for (j = 0; j < 6; j++) {    
    for (i = 0; i < 9; i++) {
      brick_list[j][i]->draw();;
    }
  }
}

void display (void) {
  
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  
  glClearColor(0.0,0.0,0.0,0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
  //gluLookAt(camera_x, camera_y, camera_z, b.x, 0.0, b.z, 0.0, 1.0, 0.0);   
  gluLookAt(camera_x, camera_y, camera_z, 10.0, 0.0, 10.0, 0.0, 1.0, 0.0);   

  ejes();

  createBricks();
  ball->draw();
  drawBricks();
  bar->draw();
  drawWalls();
  drawBackground(36, 60);
  
  keysFunc();

  glutSwapBuffers();
  //printf("%d ", rand() % 36);
  
  //glFlush();
}

void reshape (int w, int h) {
  glViewport (0, 0, (GLsizei)w, (GLsizei)h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective (60, (GLfloat)w / (GLfloat)h, 1.0, 100.0);
  glMatrixMode (GL_MODELVIEW);
} 

int main (int argc, char **argv) {
 
  glutInit (&argc, argv);

  initKeys();

  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
  glutInitWindowSize(640, 480);

  //glutInitDisplayMode (GLUT_SINGLE);
  //glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("A basic OpenGL Window");

  glShadeModel(GL_SMOOTH);
  glutDisplayFunc(display);
  glutIdleFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyPressed);

  glShadeModel(GL_SMOOTH);
  glEnable(GL_DEPTH_TEST);
  
  initGL(640, 480);
  
  glutMainLoop ();
  return 0;
}
