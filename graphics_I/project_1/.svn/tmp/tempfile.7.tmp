#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string.h>
#include <ctime>
#include <cstdlib>
#include <math.h>

#include "sphere.h"
#include "vector.h"

<<<<<<< .mine
float timer = 10.0;
=======
#define PI 3.14159265

int timer = 0;
>>>>>>> .r13

using namespace std;

Sphere::Sphere() {
  x = 18;
  z = 10;
  radius = 0.6;
  speed = 8.0;
  dir.first = x;
  dir.second = z;
  r = 0;
  l = 1;
  u = 1;
  d = 0;
  hit_bar = 0;
}

void Sphere::draw() {
  glPushMatrix();
  glColor3f(0.0,0.0,1.0);  
  glTranslatef(x, 0.5, z);
  cout << "X-ball = " << x << '\n';
  cout << "Z-ball = " << z << '\n';
  glutSolidSphere(radius,50.0,50.0);
  glPopMatrix();

  double dist = sin(45.0*PI/180);
  dist *= radius;

  glPushMatrix();

  glBegin(GL_LINES);

  if (u == 1 && l == 1) {
    glVertex3f(x + dist, 0.5, z - dist);
    glVertex3f(x + dist + 3.0, 0.5, z - dist + 3.0);

    glVertex3f(x + dist, 0.5, z + dist);
    glVertex3f(x + dist + 3.0, 0.5, z + dist + 3.0);

    glVertex3f(x - dist, 0.5, z + dist);
    glVertex3f(x - dist + 3.0, 0.5, z + dist + 3.0);
  }

  if (u == 1 && r == 1) {
    glVertex3f(x + dist, 0.5, z + dist);
    glVertex3f(x + dist - 3.0, 0.5, z + dist + 3.0);

    glVertex3f(x - dist, 0.5, z + dist);
    glVertex3f(x - dist - 3.0, 0.5, z + dist + 3.0);

    glVertex3f(x - dist, 0.5, z - dist);
    glVertex3f(x - dist - 3.0, 0.5, z - dist + 3.0);
  }

  if (d == 1 && l == 1) {
    glVertex3f(x + dist, 0.5, z + dist);
    glVertex3f(x + dist + 3.0, 0.5, z + dist - 3.0);

    glVertex3f(x + dist, 0.5, z - dist);
    glVertex3f(x + dist + 3.0, 0.5, z - dist - 3.0);

    glVertex3f(x - dist, 0.5, z - dist);
    glVertex3f(x - dist + 3.0, 0.5, z - dist - 3.0);
  }

  if (d == 1 && r == 1) {
    glVertex3f(x + dist, 0.5, z - dist);
    glVertex3f(x + dist - 3.0, 0.5, z - dist - 3.0);

    glVertex3f(x - dist, 0.5, z - dist);
    glVertex3f(x - dist - 3.0, 0.5, z - dist - 3.0);

    glVertex3f(x - dist, 0.5, z + dist);
    glVertex3f(x - dist - 3.0, 0.5, z + dist - 3.0);
  }
      
  glEnd();

  glPopMatrix();
  
//   glBegin(GL_LINES);
//   glVertex3f(x, 0.5, z);
//   if (u == 1 && l == 1)
//     glVertex3f(x + 3.0, 0.5, z + 3.0);
//   else if (u == 1 && r == 1)
//     glVertex3f(x - 3.0, 0.5, z + 3.0);
//   else if (d == 1 && l == 1)
//     glVertex3f(x + 3.0, 0.5, z - 3.0);
//   else if (d == 1 && r == 1)
//     glVertex3f(x - 3.0, 0.5, z - 3.0);  

//   glVertex3f(x + 0.6, 0.5, z);
//   if (u == 1 && l == 1)
//     glVertex3f(x + 3.6, 0.5, z + 3.0);
//   else if (u == 1 && r == 1)
//     glVertex3f(x - 2.4, 0.5, z + 3.0);
//   else if (d == 1 && l == 1)
//     glVertex3f(x + 3.6, 0.5, z - 3.0);
//   else if (d == 1 && r == 1)
//     glVertex3f(x - 2.4, 0.5, z - 3.0);

//   glVertex3f(x - 0.6, 0.5, z);
//     if (u == 1 && l == 1)
//     glVertex3f(x + 2.4, 0.5, z + 3.0);
//   else if (u == 1 && r == 1)
//     glVertex3f(x - 3.6, 0.5, z + 3.0);
//   else if (d == 1 && l == 1)
//     glVertex3f(x + 2.4, 0.5, z - 3.0);
//   else if (d == 1 && r == 1)
//     glVertex3f(x - 3.6, 0.5, z - 3.0);
  
//   glEnd();
}

void Sphere::move_to() {
  pair < float,float > dir2;
  int div;

  timer -= 0.2;
  
  if (timer <= speed) {
    timer = 10.0;
    if (x > 1 && x < 35 && z > 1 && z < 60 && hit_bar == 0) {
      if (u == 1 && l == 1) {
	x += 0.3;
	z += 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (d == 1 && l == 1) {
	x += 0.3;
	z -= 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (u == 1 && r == 1) {
	x -= 0.3;
	z += 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (d == 1 && r == 1) {
	x -= 0.3;
	z -= 0.3;
	dir.first = x;
	dir.second = z;
      }
    } else {
      //cout << "HIT" << '\n';
      dir2.first = normalize(dir).first;
      dir2.second = normalize(dir).second;
      float num = (rand()/(RAND_MAX*0.9));
      if (x <= 1) { 
	l = 1;
	r = 0;
	x += (dir2.first+0.1)*num;
      } 
      else if (x >= 35) { 
	r = 1;
	l = 0;
	x -= (dir2.first+0.1)*num;
      }
      else if (z >= 60) { 
	d = 1;
	u = 0;
	z -= (dir2.second+0.1)*num;
      } else if (z <= 1) {
	x = 18;
	z = 10;
	speed = 8.0;
	dir.first = x;
	dir.second = z;
	r = 0;
	l = 1;
	u = 1;
	d = 0;
	hit_bar = 0;      
      }
      else if (hit_bar == 1) { 
	u = 1;
	d = 0;
	z += (dir2.second+0.2);
	hit_bar = 0;
      }
      else if (hit_bar == 2) { 
	u = 0;
	d = 1;
	r = 0;
	l = 1;
	z -= (dir2.second+0.2);
	hit_bar = 0;
      }
      else if (hit_bar == 3) { 
	u = 0;
	d = 1;
	r = 1;
	l = 0;
	z -= (dir2.second+0.2);
	hit_bar = 0;
      }
    }
  }
}

bool Sphere::hit_brick(Brick* bricky) {
  bool hit = 0;
  pair < float,float > dir2;
  dir2.first = normalize(dir).first;
  dir2.second = normalize(dir).second;
  float num = (rand()/(RAND_MAX*0.9));

  if (x <= bricky->x-1.1) { 
    l = 1;
    r = 0;
    x += (dir2.first+0.1)*num;
    hit = 1;
  }
  else if (x >= bricky->x+1.1) { 
    r = 1;
    l = 0;
    x -= (dir2.first+0.1)*num;
    hit = 1;
  }
  else if (z <= bricky->z+0.6) { 
    u = 1;
    d = 0;
    z += (dir2.second+0.1)*num;
    hit = 1;
  }
  else if (z >= bricky->z-0.6) { 
    d = 1;
    u = 0;
    z -= (dir2.second+0.1)*num;
    hit = 1;
  }
  return hit;
}
