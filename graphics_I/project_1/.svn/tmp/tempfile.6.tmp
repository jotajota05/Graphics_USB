#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string.h>
#include <vector>
#include <list>

#include "brick.h"
#include "sphere.h"
#include "base.h"
#include "bonus.h"
#include "vector.h"

using namespace std;

int camera_x = 10.0;
int camera_y = 45.0;
int camera_z = -20.0;
int camera_type = 2;
pair <char,int> keys[7];
vector< vector<Brick*> > brick_list;
<<<<<<< .mine
//list< list<Brick*> > brick_list;
=======
//list< list< pair<int, int> > > brick_list_copy;
>>>>>>> .r13
Sphere* ball = new Sphere();;
Base* bar = new Base();
Bonus* b[10];
int first = 1;

void ejes() {
  glBegin(GL_LINES);
  glColor3f(1.0, 0.0, 0.0); // Eje X en rojo
  glVertex3f(200.0, 0.0, 0.0);
  glVertex3f(-200.0, 0.0, 0.0);
  glColor3f(0.0, 1.0, 0.0); // Eje Z en azul
  glVertex3f(0.0, 200.0, 0.0);
  glVertex3f(0.0, -200.0, 0.0);
  glColor3f(0.0, 0.0, 1.0); // Eje Y en verde
  glVertex3f(0.0, 0.0, 200.0);
  glVertex3f(0.0, 0.0, -200.0);
  glEnd();
}

void initGL(int width, int height) {		       
  glClearColor(0.0, 0.0, 0.0, 0.5);
  glClearDepth(1);
  glDepthFunc(GL_LESS);		
  glEnable(GL_DEPTH_TEST);		
  glShadeModel(GL_SMOOTH);	        
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();			
  gluPerspective(45.0, width/height, 0.1, 100.0);
  glMatrixMode(GL_MODELVIEW);
}

void drawBackground(int x_worldSize, int z_worldSize) {
  glColor3f(0.5f,0.5f,1.0f);
  glBegin(GL_QUADS);		
  glVertex3f(0.0, -0.1, z_worldSize);
  glVertex3f(x_worldSize, 0.0, z_worldSize);
  glVertex3f(x_worldSize, 0.0, 0.0);
  glVertex3f(0.0, -0.1, 0.0);
  glEnd();
}

void initKeys() {
  keys[0].first = 'i';
  keys[0].second = 0;

  keys[1].first = 'k';
  keys[1].second = 0;

  keys[2].first = 'l';
  keys[2].second = 0;

  keys[3].first = 'j';
  keys[3].second = 0;

  keys[4].first = 'c';
  keys[4].second = 0;

  keys[5].first = 'a';
  keys[5].second = 0;

  keys[6].first = 'd';
  keys[6].second = 0;
}

void keyPressed(unsigned char key, int x, int y) {
  int i;
  for (i = 0; i < 7; i++) {
    if (keys[i].first == key) {
      keys[i].second = 1;
      break;
    }
  }
}

int searchKey(unsigned char key) {
  int i;
  
  for (i = 0; i < 7; i++) {
    if (keys[i].first == key) {
      return keys[i].second;
    }
  }

  return 0;
}
  
void keysFunc() {  
  if (searchKey('i')) // Camera X up
    camera_x += 1;
  if (searchKey('k')) // Camera X down
    camera_x -= 1;        
  if (searchKey('l')) // Camera z up
    camera_z += 1;
  if (searchKey('j')) // Camera z down
    camera_z -= 1;
  if (searchKey('c')) { // Camera z down
    if (camera_type == 1) {
      camera_type = 2;
      camera_x = camera_x - 35.0;
      camera_y = 45.0;
      camera_z = camera_z - 16.0;
    }
    else {
      camera_type = 1;
      camera_x = camera_x + 35.0;
      camera_y = 15.0;
      camera_z = camera_z + 16.0;
    }
  }
  if (searchKey('d'))
    bar->move_rigth();
  if (searchKey('a'))
    bar->move_left();

//   cout << "Camera X " << camera_x << '\n';
//   cout << "Camera Y " << camera_y << '\n';
//   cout << "Camera Z " << camera_z << '\n';

  initKeys();
}

void drawWalls() {
  //Pared izquierda
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(0.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared derecha
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(36.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared arriba
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 60.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared abajo
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 0.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();
}

void drawBricks() {
  vector< vector<Brick*> >::iterator row_it;
  vector<Brick*>::iterator col_it;
  
  int k = 0;
  
  for (row_it = brick_list.begin(); row_it != brick_list.end(); row_it++) {
    for (col_it = (*row_it).begin(); col_it != (*row_it).end(); col_it++) {
      (*col_it)->draw();

//       if ((*col_it)->bonus.first && k < 10) {
// 	b[k++] = new Bonus((*col_it));
// 	(*col_it)->bonus.first = 0;	
//       }
    }
  }
}

void createBricks() {
  float x = 30.0;
  float z = 52.0;
  int i,j;
  vector<Brick*> aux_vec;
  Brick* aux_brick;

  for (i = 0; i < 9; i++) {
    aux_vec.clear();
    for (j = 0; j < 9; j++) {
      aux_brick = new Brick();
      aux_brick->x = x;
      aux_brick->z = z;
      aux_brick->red = 0.8;
      aux_brick->matrix_pos.first = i;
      aux_brick->matrix_pos.second = j;
      
      x -= 3.0;
      aux_vec.push_back(aux_brick);
    }

    brick_list.push_back(aux_vec);

    x = 30.0;
    z -= 3.0;
  }
}

//Los bricks verdes son los estaticos
void chooseStaticBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  for (i = 0; i < 10; i++) {
    rand_row_val = rand() % 9;
    rand_col_val = rand() % 9;
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    aux->type = 1;
    aux->red = 0.0;
    aux->green = 0.8;
  }
}

//Los bricks azules son los que tienen bonus que agranda la base
void chooseBaseBonusBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  i = 0;
  while(i < 5) {    
    rand_row_val = rand() % 9;
    rand_col_val = rand() % 9;    
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    
    if (aux->type == 0) {
      aux->bonus.first = 1;
      aux->red = 0.0;
      aux->blue = 0.8;
      i++;
    }    
  }
}

//Los bricks rosados son los que tienen bonus que aumenta la velocidad de la pelota
void chooseBallBonusBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  i = 0;
  while(i < 5) {    
    rand_row_val = rand() % 9;
    rand_col_val = rand() % 9;    
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    
    //cout << "type: " << aux->type << " bonus.first: " << aux->bonus.first << "\n";
    //sleep(1);
    
    if ((aux->type == 0) && (aux->bonus.first == 0)) {
      aux->bonus.first = 1;
      aux->bonus.second = 1;
      aux->blue = 0.8;
      i++;
    }    
  }
}

void hit_bar(Sphere* ball, Base* bar) {
<<<<<<< .mine
  if (ball->z <= (bar->z)+0.6 && 
      ball->z >= (bar->z)+0.4 && 
      ball->x > (bar->x - bar->longt/2) && 
      ball->x < (bar->x + bar->longt/2))
=======
  if (ball->z <= (bar->z)+1.5  && 
      ball->z >= (bar->z)-1.5 && 
      ball->x >= (bar->x - bar->longt/2)-0.5 && 
      ball->x <= (bar->x + bar->longt/2)+0.5) {
>>>>>>> .r13
    ball->hit_bar = 1;
  else
    if (ball->z <= (bar->z)+0.6 && 
	ball->z >= (bar->z)-0.6 && 
	ball->x >= (bar->x + bar->longt/2)-0.4 &&
	ball->x <= (bar->x + bar->longt/2)+0.4)
      ball->hit_bar = 2;
  else 
    if (ball->z <= (bar->z)+0.6 && 
	ball->z >= (bar->z)-0.6 && 
	ball->x <= (bar->x - bar->longt/2)+0.4 &&
	ball->x >= (bar->x - bar->longt/2)-0.4)
      ball->hit_bar = 3;
}

pair<int, int> detectCollisionBrick() {
  vector< vector<Brick*> >::iterator row_it;
  vector<Brick*>::iterator col_it;
  int i, j;
  i = j = 0;
  
  for (row_it = brick_list.begin(); row_it != brick_list.end(); row_it++) {
    for (col_it = (*row_it).begin(); col_it != (*row_it).end(); col_it++) {
      if (ball->u == 1 && ball->l == 1) {
	if ((((ball->x + 3.0) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 3.0) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x + 3.6) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 3.6) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x + 2.4) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 2.4) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5)))) {
	  return pair<int, int> (i, j);
	}
      }
      else if (ball->u == 1 && ball->r == 1) {
	if ((((ball->x - 3.0) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 3.0) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x - 2.4) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 2.4) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x - 3.6) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 3.6) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z + 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z + 3.0) >= ((*col_it)->z - 1.5)))) {
	  return pair<int, int> (i, j);
	}	
      }
      else if (ball->d == 1 && ball->l == 1) {
	if ((((ball->x + 3.0) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 3.0) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x + 3.6) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 3.6) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x + 2.4) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x + 2.4) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5)))) {
	  return pair<int, int> (i, j);
	}
      }
      else if (ball->d == 1 && ball->r == 1) {
	if ((((ball->x - 3.0) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 3.0) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x - 2.4) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 2.4) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5))) ||
	    (((ball->x - 3.6) >= ((*col_it)->x - 1.5)) && 
	    ((ball->x - 3.6) <= ((*col_it)->x + 1.5)) && 
	    ((ball->z - 3.0) <= ((*col_it)->z + 1.5)) && 
	    ((ball->z - 3.0) >= ((*col_it)->z - 1.5)))) {
	  return pair<int, int> (i, j);
	}
      }
      j++;
    }
    i++;
    j = 0;
  }

  i = j = -1;
  return pair<int, int> (i, j);
}

void check_hits_bricks() {
  vector< vector<Brick*> >::iterator it1;
  vector<Brick*>::iterator it2;
  int i, j;
  
   i = detectCollisionBrick().first;
   j = detectCollisionBrick().second;
   it1 = brick_list.begin() + i;
   it2 = (*it1).begin() + j;
   if (ball->hit_brick(*it2)) 
     (*it1).erase(it2);

//   //if (ball->hit_brick(*col_it) == 1) {
//     j = detectCollisionBrick().first;
//     k = detectCollisionBrick().second;
//     row_it = brick_list.begin() + j;
//     //ball->hit_brick(*((*row_it).begin()))
//     (*row_it).erase((*row_it).begin() + k);

    //(*col_it).erase(col_it.begin() + k);
    //*(brick_list.begin() + j).erase(((brick_list.begin()+j)).begin() + k);
    
  // for (row_it = brick_list.begin(); row_it != brick_list.end(); row_it++) 
//     for (col_it = (*row_it).begin(); col_it != (*row_it).end(); col_it++) 
//       if (ball->hit_brick(*col_it) == 1) {
// 	//(*row_it).erase(col_it);
// 	detectCollisionBrick()
//       }
}

void display (void) {
  
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  
  glClearColor(0.0,0.0,0.0,0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
  //gluLookAt(camera_x, camera_y, camera_z, b.x, 0.0, b.z, 0.0, 1.0, 0.0);   
  gluLookAt(camera_x, camera_y, camera_z, 10.0, 0.0, 10.0, 0.0, 1.0, 0.0);   

  keysFunc();

  ejes();
  hit_bar(ball,bar);
  ball->draw();
  drawBricks();
  bar->draw();
  hit_bar(ball,bar);
  drawWalls();
  drawBackground(36, 60);
<<<<<<< .mine
  ball->move_to();

  check_hits_bricks();

  pair<int, int> nose = detectCollisionBrick();
  // if (nose.first != -1 && nose.second != -1) {
//     printf("fila = %d columna = %d\n", nose.first, nose.second);
//   }
=======
  //ball->move_to();
  //pair<int, int> nose = detectCollisionBrick();
  
  // if (nose.first != -1 && nose.second != -1) {
  //     printf("fila = %d columna = %d\n", nose.first, nose.second);
  //   }
>>>>>>> .r13
  //brick_distances();
  //vector<Brick*> close = chooseCloseBricks();

  keysFunc();

  glutSwapBuffers();

  //glFlush();
}

void reshape (int w, int h) {
  glViewport (0, 0, (GLsizei)w, (GLsizei)h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective (60, (GLfloat)w / (GLfloat)h, 1.0, 100.0);
  glMatrixMode (GL_MODELVIEW);
} 

int main (int argc, char **argv) {

  srand(time(NULL));
 
  glutInit (&argc, argv);
  createBricks();
  chooseStaticBricks();
  chooseBaseBonusBricks();
  chooseBallBonusBricks();
  
  initKeys();

  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
  glutInitWindowSize(640, 480);

  //glutInitDisplayMode (GLUT_SINGLE);
  //glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("A basic OpenGL Window");

  glShadeModel(GL_SMOOTH);
  glutDisplayFunc(display);
  glutIdleFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyPressed);

  glShadeModel(GL_SMOOTH);
  glEnable(GL_DEPTH_TEST);
  
  initGL(640, 480);
  
  glutMainLoop ();
  return 0;
}
