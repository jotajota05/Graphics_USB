#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string.h>
#include <ctime>
#include <cstdlib>
#include <math.h>

#include "sphere.h"
#include "vector.h"

int timer = 0;

using namespace std;

Sphere::Sphere() {
  x = 18;
  z = 10;
  radius = 0.6;
  speed = 5;
  dir.first = x;
  dir.second = z;
  r = 0;
  l = 1;
  u = 1;
  d = 0;
  hit_bar = 0;
}

void Sphere::draw() {
  glPushMatrix();
  glColor3f(0.0,0.0,1.0);  
  glTranslatef(x, 0.5, z);
  glutSolidSphere(radius,50.0,50.0);
  glPopMatrix();
  timer++;
  
  glBegin(GL_LINES);
  glVertex3f(x, 0.5, z);
  if (u == 1 && l == 1)
    glVertex3f(x + 10.0, 0.5, z + 10.0);
  else if (u == 1 && r == 1)
    glVertex3f(x - 10.0, 0.5, z + 10.0);
  else if (d == 1 && l == 1)
    glVertex3f(x + 10.0, 0.5, z - 10.0);
  else if (d == 1 && r == 1)
    glVertex3f(x - 10.0, 0.5, z - 10.0);  

  glVertex3f(x + 0.6, 0.5, z);
  if (u == 1 && l == 1)
    glVertex3f(x + 10.6, 0.5, z + 10.0);
  else if (u == 1 && r == 1)
    glVertex3f(x - 9.4, 0.5, z + 10.0);
  else if (d == 1 && l == 1)
    glVertex3f(x + 10.6, 0.5, z - 10.0);
  else if (d == 1 && r == 1)
    glVertex3f(x - 9.4, 0.5, z - 10.0);

  glVertex3f(x - 0.6, 0.5, z);
    if (u == 1 && l == 1)
    glVertex3f(x + 9.4, 0.5, z + 10.0);
  else if (u == 1 && r == 1)
    glVertex3f(x - 10.6, 0.5, z + 10.0);
  else if (d == 1 && l == 1)
    glVertex3f(x + 9.4, 0.5, z - 10.0);
  else if (d == 1 && r == 1)
    glVertex3f(x - 10.6, 0.5, z - 10.0);
  
  glEnd();
}

void Sphere::move_to() {
  pair < float,float > dir2;
  int div;

  if (speed <= 1.0) 
    div = 10;
  else if (speed > 1.0 && speed <= 2.0) 
    div = 8;
  else if (speed > 2.0) 
    div = 4;

  if (timer % div == 0)
    if (x > 1 && x < 35 && z > 1 && z < 60 && hit_bar == 0) {
      if (u == 1 && l == 1) {
	x += 0.3;
	z += 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (d == 1 && l == 1) {
	x += 0.3;
	z -= 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (u == 1 && r == 1) {
	x -= 0.3;
	z += 0.3;
	dir.first = x;
	dir.second = z;
      } 
      else if (d == 1 && r == 1) {
	x -= 0.3;
	z -= 0.3;
	dir.first = x;
	dir.second = z;
      }
    } 
    else {
      dir2.first = normalize(dir).first;
      dir2.second = normalize(dir).second;
      float num = (rand()/(RAND_MAX*0.9));
      //cout << num << '\n';

      if (x <= 1) { 
	l = 1;
	r = 0;
	x += (dir2.first+0.1)*num;
      }
      else if (x >= 35) { 
	r = 1;
	l = 0;
	x -= (dir2.first+0.1)*num;
      }
      else if (hit_bar == 1 || z <= 1) { 
	u = 1;
	d = 0;
	z += (dir2.second+0.1)*num;
	hit_bar = 0;
      }
      else if (z >= 60) { 
	d = 1;
	u = 0;
	z -= (dir2.second+0.1)*num;
      }
    }
}

bool Sphere::hit_brick(Brick* bricky) {
  bool hit = 0;
  pair < float,float > dir2;
  dir2.first = normalize(dir).first;
  dir2.second = normalize(dir).second;
  float num = (rand()/(RAND_MAX*0.9));

  if (x <= bricky->x-1.1) { 
    l = 1;
    r = 0;
    x += (dir2.first+0.1)*num;
    hit = 1;
  }
  else if (x >= bricky->x+1.1) { 
    r = 1;
    l = 0;
    x -= (dir2.first+0.1)*num;
    hit = 1;
  }
  else if (z <= bricky->z+0.6) { 
    u = 1;
    d = 0;
    z += (dir2.second+0.1)*num;
    hit = 1;
  }
  else if (z >= bricky->z-0.6) { 
    d = 1;
    u = 0;
    z -= (dir2.second+0.1)*num;
    hit = 1;
  }
  return hit;
}
