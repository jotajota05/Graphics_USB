#include <GL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string.h>
#include <vector>

#include "brick.h"
#include "sphere.h"
#include "base.h"
#include "bonus.h"
#include "vector.h"

using namespace std;

int camera_x = 10.0;
int camera_y = 45.0;
int camera_z = -20.0;
int camera_type = 2;
pair <char,int> keys[7];
vector< vector<Brick*> > brick_list;
Sphere* ball = new Sphere();;
Base* bar = new Base();
Bonus* b[10];
int first = 1;
vector< pair< double, pair<int, int> > > brick_dist;

void ejes() {
  glBegin(GL_LINES);
  glColor3f(1.0, 0.0, 0.0); // Eje X en rojo
  glVertex3f(200.0, 0.0, 0.0);
  glVertex3f(-200.0, 0.0, 0.0);
  glColor3f(0.0, 1.0, 0.0); // Eje Z en azul
  glVertex3f(0.0, 200.0, 0.0);
  glVertex3f(0.0, -200.0, 0.0);
  glColor3f(0.0, 0.0, 1.0); // Eje Y en verde
  glVertex3f(0.0, 0.0, 200.0);
  glVertex3f(0.0, 0.0, -200.0);
  glEnd();
}

void initGL(int width, int height) {		       
  glClearColor(0.0, 0.0, 0.0, 0.5);
  glClearDepth(1);
  glDepthFunc(GL_LESS);		
  glEnable(GL_DEPTH_TEST);		
  glShadeModel(GL_SMOOTH);	        
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();			
  gluPerspective(45.0, width/height, 0.1, 100.0);
  glMatrixMode(GL_MODELVIEW);
}

void drawBackground(int x_worldSize, int z_worldSize) {
  glColor3f(0.5f,0.5f,1.0f);
  glBegin(GL_QUADS);		
  glVertex3f(0.0, -0.1, z_worldSize);
  glVertex3f(x_worldSize, 0.0, z_worldSize);
  glVertex3f(x_worldSize, 0.0, 0.0);
  glVertex3f(0.0, -0.1, 0.0);
  glEnd();
}

void initKeys() {
  keys[0].first = 'i';
  keys[0].second = 0;

  keys[1].first = 'k';
  keys[1].second = 0;

  keys[2].first = 'l';
  keys[2].second = 0;

  keys[3].first = 'j';
  keys[3].second = 0;

  keys[4].first = 'c';
  keys[4].second = 0;

  keys[5].first = 'a';
  keys[5].second = 0;

  keys[6].first = 'd';
  keys[6].second = 0;
}

void keyPressed(unsigned char key, int x, int y) {
  int i;
  for (i = 0; i < 7; i++) {
    if (keys[i].first == key) {
      keys[i].second = 1;
      break;
    }
  }
}

int searchKey(unsigned char key) {
  int i;
  
  for (i = 0; i < 7; i++) {
    if (keys[i].first == key) {
      return keys[i].second;
    }
  }

  return 0;
}
  
void keysFunc() {  
  if (searchKey('i')) // Camera X up
    camera_x += 1;
  if (searchKey('k')) // Camera X down
    camera_x -= 1;        
  if (searchKey('l')) // Camera z up
    camera_z += 1;
  if (searchKey('j')) // Camera z down
    camera_z -= 1;
  if (searchKey('c')) { // Camera z down
    if (camera_type == 1) {
      camera_type = 2;
      camera_x = camera_x - 35.0;
      camera_y = 45.0;
      camera_z = camera_z - 16.0;
    }
    else {
      camera_type = 1;
      camera_x = camera_x + 35.0;
      camera_y = 15.0;
      camera_z = camera_z + 16.0;
    }
  }
  if (searchKey('d'))
    bar->move_rigth();
  if (searchKey('a'))
    bar->move_left();

//   cout << "Camera X " << camera_x << '\n';
//   cout << "Camera Y " << camera_y << '\n';
//   cout << "Camera Z " << camera_z << '\n';

  initKeys();
}

void drawWalls() {
  //Pared izquierda
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(0.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared derecha
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(36.0, 0.6, 30.0);
  glScalef(1.0, 2.0, 120.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared arriba
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 60.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();

  //Pared abajo
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0);
  glTranslatef(18.0, 0.6, 0.0);
  glRotatef(90, 0.0, 1.0, 0.0);
  glScalef(1.0, 2.0, 73.0);
  glutSolidCube(0.5);
  glPopMatrix();
}

void drawBricks() {
  vector< vector<Brick*> >::iterator row_it;
  vector<Brick*>::iterator col_it;
  
  int k = 0;
  
  for (row_it = brick_list.begin(); row_it != brick_list.end(); row_it++) {
    for (col_it = (*row_it).begin(); col_it != (*row_it).end(); col_it++) {
      (*col_it)->draw();

//       if ((*col_it)->bonus.first && k < 5) {
// 	b[k++] = new Bonus((*col_it));
// 	(*col_it)->bonus.first = 0;	
//       }
    }
  }
}

void createBricks() {
  float x = 30.0;
  float z = 52.0;
  int i,j;
  vector<Brick*> aux_vec;
  Brick* aux_brick;

  for (i = 0; i < 6; i++) {
    aux_vec.clear();
    for (j = 0; j < 9; j++) {
      aux_brick = new Brick();
      aux_brick->x = x;
      aux_brick->z = z;
      aux_brick->red = 0.8;
      
      x -= 3.0;
      aux_vec.push_back(aux_brick);
    }

    brick_list.push_back(aux_vec);

    x = 30.0;
    z -= 3.0;
  }
}

//Los bricks verdes son los estaticos
void chooseStaticBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  for (i = 0; i < 10; i++) {
    rand_row_val = rand() % 6;
    rand_col_val = rand() % 9;
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    aux->type = 1;
    aux->red = 0.0;
    aux->green = 0.8;
  }
}

//Los bricks azules son los que tienen bonus que agranda la base
void chooseBaseBonusBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  i = 0;
  while(i < 5) {    
    rand_row_val = rand() % 6;
    rand_col_val = rand() % 9;    
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    
    if (aux->type == 0) {
      aux->bonus.first = 1;
      aux->red = 0.0;
      aux->blue = 0.8;
      i++;
    }    
  }
}

//Los bricks ? son los que tienen bonus que aumenta la velocidad de la pelota
void chooseBallBonusBricks() {
  int rand_row_val, rand_col_val, i;
  Brick* aux;
   
  i = 0;
  while(i < 5) {    
    rand_row_val = rand() % 6;
    rand_col_val = rand() % 9;    
    aux = brick_list.at(rand_row_val).at(rand_col_val);
    
    if ((aux->type == 0) && (aux->bonus.first == 0)) {
      aux->bonus.first = 1;
      aux->bonus.second = 1;
      aux->blue = 0.8;
      i++;
      printf("iiiiiiiiii -> %d\n", i);
    }    
    else {
      printf("no me estoy quedando pegado");
    }
  }
}

void hit_bar(Sphere* ball, Base* bar) {
  if (ball->z <= (bar->z)+1.5 && 
      ball->z >= (bar->z)-1.5 && 
      ball->x >= (bar->x - bar->longt/2)-0.5 && 
      ball->x <= (bar->x + bar->longt/2)+0.5) {
    ball->hit_bar = 1;
  }
}

void brick_distances() {
  vector< vector<Brick*> >::iterator row_it;
  vector<Brick*>::iterator col_it;
  pair<int, int> aux_pos;
  int i, j;
  i = j = 0;
  
  for (row_it = brick_list.begin(); row_it != brick_list.end(); row_it++) {
    for (col_it = (*row_it).begin(); col_it != (*row_it).end(); col_it++) {
      aux_pos.first = i;
      aux_pos.second = j;
      brick_dist.push_back(pair< double, pair<int, int> > (module(substract(pair<float, float> (ball->x, ball->z), pair<float, float> ((*col_it)->x, (*col_it)->z))), aux_pos));                  
      j++;
    }
    i++;
    j = 0;
  }
}

vector<Brick*> chooseCloseBricks() {
  vector< pair< double, pair<int, int> > > aux (brick_dist);
  vector< pair< double, pair<int, int> > >::iterator aux_it;
  int i, j, min_pos;
  double min;
  vector<Brick*> close;
  
  for (i = 0; i < 5; i++) {
    j = 0;
    min = aux.front().first;
    min_pos = j;
    for (aux_it = aux.begin(); aux_it != aux.end(); aux_it++) {
      if (min < (*aux_it).first) {
	min = (*aux_it).first;
	min_pos = j;
      }	
      j++;
    }
    close.push_back(brick_list.at(aux.at(min_pos).second.first).at(aux.at(min_pos).second.second));
    aux_it = aux.begin();
    aux_it += min_pos;
    aux.erase(aux_it);
  }

  return close;
  
<<<<<<< .mine
  for (i = 0; i < 5; i ++) {    
    j = 0;
    for (it = aux.begin(); it != aux.end(); it++) {
      if ((*it) < min)
	min = (*it);
    }
  }
 
=======
>>>>>>> .r10
}

void display (void) {
  
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  
  glClearColor(0.0,0.0,0.0,0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
  //gluLookAt(camera_x, camera_y, camera_z, b.x, 0.0, b.z, 0.0, 1.0, 0.0);   
  gluLookAt(camera_x, camera_y, camera_z, 10.0, 0.0, 10.0, 0.0, 1.0, 0.0);   

  keysFunc();

  ejes();
  hit_bar(ball,bar);
  ball->draw();
  drawBricks();
  bar->draw();
  hit_bar(ball,bar);
  drawWalls();
  drawBackground(36, 60);
  ball->move_to();
  brick_distances();

  keysFunc();

  glutSwapBuffers();

  //glFlush();
}

void reshape (int w, int h) {
  glViewport (0, 0, (GLsizei)w, (GLsizei)h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective (60, (GLfloat)w / (GLfloat)h, 1.0, 100.0);
  glMatrixMode (GL_MODELVIEW);
} 

int main (int argc, char **argv) {

  srand(time(NULL));
 
  glutInit (&argc, argv);
  createBricks();
  chooseStaticBricks();
  chooseBaseBonusBricks();
  //chooseBallBonusBricks();

  initKeys();

  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_ALPHA | GLUT_DEPTH);
  glutInitWindowSize(640, 480);

  //glutInitDisplayMode (GLUT_SINGLE);
  //glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("A basic OpenGL Window");

  glShadeModel(GL_SMOOTH);
  glutDisplayFunc(display);
  glutIdleFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyPressed);

  glShadeModel(GL_SMOOTH);
  glEnable(GL_DEPTH_TEST);
  
  initGL(640, 480);
  
  glutMainLoop ();
  return 0;
}
